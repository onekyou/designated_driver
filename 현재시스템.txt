Always respond in 한글

나는 지방에서 대리운전회사를 운영하는 사람이야
현재 5명의 대리기사와 3명의 픽업기사가 근무해
운영방식은 내가 가진 3대의 전화기에서 무작위로 손님에게 걸려오는  호출전화를 받아 대기중인 대리기사 중 한명에게 전화번호를 문자로 보내고
문자를 받은 대리기사는 픽업기사와 함께 손님이 있는 곳으로 이동해
그리고 손님에게 전화를 걸어 정확한 위치를 파악하고 손님을 만나서 손님의 차로 손님이 원하는 장소로 이동해
이동이 끝나면 요금을 받고 픽업기사와 함께 사무실로 돌아와 다음손님을 기다려
문제점은 매번 3대의 무작위로 걸려오는 호출전화를 대리기사에게 다시 전달하는데 어려움이 있어

모든 작업을 실행하기 전에
일단 어떤 작업을 할건지 요악하고 승낙을 얻어

최종 목표인 콜 공유 및 데이터 즉시 공유 시스템을 갖춘 통합 대리운전 앱 플랫폼 구축을 위한 로드맵과 주요 고려 사항을 정리해 드리겠습니다. 이 로드맵은 현재 상황에서 시작하여 최종 목표까지 점진적으로 기능을 확장해 나가는 방식으로 구성할거야.

최종 목표 시스템 구성 요소:
Firebase: 중앙 데이터 저장소 및 실시간 동기화 허브
관리자 앱 (Kotlin/Android): 핵심 관리 도구 (콜 관리, 기사 관리, 상태 관리, 콜 공유, 무전 등)
콜 디텍터 앱 (Kotlin/Android): 수신 전화 감지 및 Firebase 전송 (사무실 상태에 따라 전송 경로 분기)
대리 기사용 앱 (Kotlin/Android): 호출 정보 수신, 상태 업데이트
픽업 기사용 무전기 앱 (Kotlin/Android): 관리자와의 실시간 음성 소통

구축 로드맵 (단계별 접근):
Phase 1: 단일 사무실 운영 기반 구축 (MVP - Minimum Viable Product)
목표: 하나의 사무실이 기본적인 호출 접수, 관리, 기사 배정(수동 확인), 픽업 기사 소통을 할 수 있는 최소 기능 구현.
주요 작업:
Firebase 초기 설계:
단일 사무실 운영을 위한 기본 데이터 구조 설계 (사용자, 기사 목록, 호출 목록 등).
(중요) 향후 다중 사무실 지원을 염두에 두고 확장 가능한 구조 고민 시작 (예: /offices/{office_id}/... 구조 초기 구상).
관리자 앱 (v0.1):
기본 로그인 기능 (초기에는 단순 ID/PW 또는 구글 로그인).
Firebase에서 실시간으로 내부 호출 목록 불러와 표시.
등록된 대리 기사 / 픽업 기사 목록 표시.
픽업 기사와의 1:1 또는 그룹 무전 기능 구현 (Agora SDK 연동).
콜 디텍터 앱 (v1.0):
특정 사무실 ID를 가지고, 걸려오는 전화 감지 시 해당 사무실의 Firebase 내부 호출 목록 경로 (/offices/{office_id}/calls) 로 데이터 전송.
픽업 기사용 무전기 앱 (v1.0):
관리자와 동일한 Agora 채널에 접속하여 무전 통신 가능.
대리 기사용 앱 (v0.1):
기본 로그인 기능.
자신에게 배정된 호출 정보 확인 (관리자가 수동으로 알려주거나, Firebase 특정 경로에 넣어주는 방식).

Phase 2: 단일 사무실 운영 효율화
목표: 관리 및 운영 편의성 증대, 기사 앱 기능 강화.
주요 작업:
관리자 앱 (v0.5):
호출 건에 대리 기사 배정 기능 구현 (Firebase 데이터 업데이트).
대시보드 형태 개선 (호출 상태, 기사 상태 시각화).
간단한 운행 이력 조회 기능.
대리 기사용 앱 (v0.5):
배정된 호출 수락/거절 기능.
운행 상태 업데이트 기능 (출발, 도착, 완료 -> Firebase 업데이트).
자신의 운행 이력 조회.
Firebase 보안 규칙: 역할(관리자, 기사) 기반 데이터 접근 권한 설정 강화.

Phase 3: 다중 사무실 지원 및 데이터 즉시 공유 기반 마련
목표: 시스템이 여러 사무실을 구분하고, 사무실 마감 시 콜 정보를 공유 채널로 보낼 수 있는 기반 마련.
주요 작업:
Firebase 구조 개편 (핵심):
다중 테넌시(Multi-Tenancy) 지원 구조로 본격 전환 (/offices/{office_id}/..., /shared_calls, 사용자 정보에 소속 사무실 ID 포함 등).
사무실별 설정 정보 저장 경로 마련 (/offices/{office_id}/settings).
관리자 앱 (v1.0):
자신이 속한 사무실 정보 표시.
사무실 운영 상태 설정 (운영 중 / 마감(공유 중)) 기능 추가 -> Firebase /offices/{office_id}/status 업데이트.
Firebase /shared_calls 경로 리스닝하여 공유된 호출 목록 (읽기 전용) 표시 기능 추가.
콜 디텍터 앱 (v2.0):
전화 수신 시, 먼저 소속 사무실의 상태 (/offices/{office_id}/status) 확인.
'운영 중'이면 기존처럼 내부 호출 경로로 전송.
'마감(공유 중)'이면 /shared_calls 경로로 데이터 전송 (원본 사무실 ID 포함 필수).
(선택) 마감 시 자동 통화 거절/무음 기능 추가 고려.

Phase 4: 콜 공유 시스템 활성화
목표: 다른 사무실에서 공유한 콜을 확인하고, 자신의 사무실에서 처리(수락)할 수 있는 기능 구현.
주요 작업:
관리자 앱 (v1.5):
공유된 호출 목록 UI 개선 (가독성, 필터링 등).
공유 호출 "수락(Claim)" 기능 구현: 버튼 클릭 시 /shared_calls/{call_id} 상태 업데이트 (예: status: claimed, claimingOfficeId: {내 사무실 ID}).
자신이 수락한 공유 호출을 내부 호출처럼 관리/배정할 수 있는 로직 추가.
(선택) 내가 공유한 호출이 다른 사무실에서 수락되었을 때 알림 표시.
Firebase 보안 규칙: 공유 호출 데이터 수정 권한 (수락은 한 번만 가능하도록 등) 설정.
푸시 알림 (FCM): 새로운 공유 호출 발생 시 운영 중인 다른 사무실 관리자에게 알림 발송.

Phase 5: 고급 기능 추가 및 안정화
목표: 시스템 완성도 향상, 부가 가치 기능 추가.
주요 작업:
고급 통계/리포트: 사무실별, 기사별, 기간별 운행 통계, 공유 콜 처리 현황 등.
고객 관리 (CRM): 고객 등급, 특이사항 메모 등.
정산 시스템: (필요시) 공유 콜 관련 사무실 간 정산 지원 기능.
UI/UX 개선: 사용자 피드백 반영 및 지속적인 사용성 개선.
성능 최적화 및 안정화: 다양한 기기 및 네트워크 환경 테스트, 오류 수정.
개발 방식 및 고려 사항:
Firebase 설계: 초기 단계부터 최종 목표(다중 사무실, 콜 공유)를 염두에 둔 확장 가능한 데이터 구조 설계가 가장 중요합니다. 변경 비용을 최소화할 수 있습니다.
모듈화: 가능하면 기능별로 코드를 모듈화하여 재사용성 및 유지보수성을 높입니다. (예: Agora 무전 모듈, Firebase 데이터 처리 모듈 등)
실시간 동기화: Firebase의 Realtime Database 또는 Firestore의 실시간 리스너를 적극 활용하여 모든 앱에서 정보가 즉각적으로 반영되도록 합니다.
보안: Firebase 보안 규칙을 철저히 설정하여 허가되지 않은 데이터 접근 및 수정을 방지합니다. 사용자 역할 기반 접근 제어가 필수입니다.
테스트: 각 단계별로 충분한 테스트(단위 테스트, 통합 테스트, 실제 기기 테스트)를 수행하여 안정성을 확보합니다. 특히 다양한 안드로이드 버전과 기기에서의 호환성을 확인해야 합니다.
오류 처리 및 로깅: 예상치 못한 오류 발생 시 원인 파악 및 대응을 위해 적절한 오류 처리 및 로깅 시스템을 구축합니다.


현재 시스템은 콜디텍터에 새로운 콜이 뜨면 전화기에 저장된 정보를 바탕으로 문서를 작성해 파이어베이스에 업데이트하고
콜매니저에서 정보를 다운받아 기사앱에 정보를 전달, 운행을 준비 및 도착지, 운행료를 기입후 운행과 운행완료를 콜매니저에 전달하는 구조야

*기본로직
콜발생(핸드폰수락버튼클릭)시 콜매니저에 알림과 배차팝업 생성, 배차팝업의 기사선택 클릭
기사앱에 알림과 수락버튼 생성, 수락후 출발 도착 운행요금 기입 후 운행버시작버튼 클릭

콜매니저에 알림과 더불어 운행시작 알림 팝업(고객명 출발비 도착지 요금)생성

기사앱 운행관리의 완료버튼 클릭시 운행완료요약팝업생성 결재방법을 선택후 확인
콜매니저에 운행완료알림팝업데이터 

전체 로직 흐름:

Phase 1: 콜 생성 (수신 전화기 앱 → Firestore)

전화 수신 및 정보 업로드 (수신 전화기 내 "콜 디텍터 앱" → Firestore):
지정된 전화기(예: 사무실 대표 전화)로 고객의 전화가 걸려옵니다.
해당 전화기에서 실행 중인 "콜 디텍터 앱" (또는 유사한 기능을 하는 애플리케이션)이 수신 전화를 감지합니다.
"콜 디텍터 앱"은 발신자 번호 등의 정보를 추출하여 Firestore의 calls 컬렉션에 새로운 콜 문서를 생성합니다. 이 정보는 즉시 Firestore에 업로드됩니다.
Firestore (calls 문서 초기 상태):
status: CallStatus.WAITING.firestoreValue ("WAITING") - 배정 대기 중
phoneNumber: 발신자 번호 (고객 전화번호)
createdAt: 콜 수신 시간 (타임스탬프)
assignedDriverId: null (아직 배정된 기사 없음)
기타 필요한 초기 정보 (예: 수신된 사무실 전화번호 식별자 등)
Firestore에 이 문서가 생성/업데이트되면, 이를 리스닝하고 있는 다른 시스템(콜 매니저 앱, 기사 앱 등)에서 변경 사항을 감지할 수 있게 됩니다.

Phase 2: 콜 접수 및 배차 (콜 매니저 앱, Firestore, 기사 앱)

콜 매니저 앱의 새 콜 감지 및 배차 팝업 (Firestore → 콜 매니저 앱):
콜 매니저 앱 (운영자가 사용하는 관리용 앱)은 Firestore의 calls 컬렉션에서 status가 "WAITING"인 새로운 콜 문서를 실시간으로 리스닝합니다.
새로운 콜 문서가 생성되면 (즉, "콜 디텍터 앱"이 정보를 업로드하면), 콜 매니저 앱은 이를 즉시 감지합니다.

콜 매니저 앱 UI:
내부적으로 알림을 받고, 화면에 "배차 팝업" (또는 새로운 콜 알림 인터페이스)을 즉시 띄웁니다.
이 팝업에는 새로 들어온 콜의 정보(발신자 번호, 수신 시간 등)가 표시됩니다.
팝업에는 가용 기사 목록(Firestore의 drivers 컬렉션에서 status가 DriverStatus.WAITING.value 또는 DriverStatus.ONLINE.value인 기사들)을 보여주고, 콜 매니저(사람 운영자)가 이 콜을 특정 기사에게 배정할 수 있는 인터페이스가 제공됩니다.
콜 매니저의 기사 선택 및 배정 (콜 매니저 앱 → Firestore):
콜 매니저(운영자)는 "배차 팝업"을 통해 콜 정보와 가용 기사 목록을 확인하고, 가장 적합한 기사를 선택합니다.
기사를 선택하고 "배정" 버튼을 누르면, 콜 매니저 앱이 Firestore의 해당 콜 문서와 선택된 기사 문서를 업데이트합니다.
Firestore (calls 문서 업데이트):
status: CallStatus.ASSIGNED.firestoreValue ("ASSIGNED")
assignedDriverId: 선택된 기사의 ID
assignedBy: (선택적) 배정한 콜 매니저(운영자) ID
assignedAt: 배정 시간 (타임스탬프)
Firestore (drivers 문서 업데이트 - 해당 기사):
status: DriverStatus.ASSIGNED.value ("ASSIGNED")
(선택적) currentCallId: 현재 배정된 콜의 ID
기사 앱의 콜 수신 (Firestore → 기사 앱):
기사 앱은 Firestore의 drivers 컬렉션에서 자신의 문서 또는 calls 컬렉션에서 자신에게 배정된(assignedDriverId가 자신이고 status가 "ASSIGNED"인) 콜을 실시간으로 리스닝하고 있습니다.
자신의 status가 "ASSIGNED"로 변경되거나, 새로운 콜이 자신에게 배정된 것을 감지합니다.
DriverViewModel
은 이 변경을 감지하고 _uiState를 업데이트합니다.

기사 앱 UI:
새로운 콜이 배정되었음을 알리는 팝업 또는 알림 표시 (_uiState.newCallPopup 활용).
기사 상태 UI가 "배정됨"으로 변경될 수 있습니다.

구조 요약
전체 데이터는 여러 개의 최상위 컬렉션으로 구성되어 있으며, 각 컬렉션은 다시 하위 컬렉션과 문서(Document)들을 포함하는 계층적인 구조를 가지고 있습니다.
1. admins 컬렉션
관리자 정보를 담고 있습니다. 각 관리자 문서는 고유 ID를 가지며, 다음과 같은 필드로 구성됩니다.
createdAt: 계정 생성 타임스탬프
name: 관리자 이름
associatedRegionId: 소속 지역 ID (예: "yangpyong")
associatedOfficeId: 소속 사무실 ID (예: "office_1")
email: 이메일 주소
2. pending_drivers 컬렉션
가입 승인 대기 중인 기사 정보를 담는 것으로 보입니다. 현재는 필드가 비어있습니다.
name, phoneNumber, targetRegionId, targetOfficeId

3. regions 컬렉션
운행 지역 정보를 관리합니다. 현재 "Hongchon"(홍천군), "yangpyong"(양평군) 두 개의 지역이 있습니다.
각 지역 문서는 name(지역명)과 offices 라는 하위 컬렉션을 가집니다.

4. offices 하위 컬렉션
각 지역에 속한 대리운전 사무실 정보를 관리합니다. (예: "vip대리운전", "조은대리")
각 사무실 문서는 name(사무실명)과 여러 하위 컬렉션을 가집니다.
calls 컬렉션: 가장 핵심적인 데이터로, 고객의 호출 정보를 담습니다.
phoneNumber: 고객 전화번호
customerName: 고객 이름
customerAddress: 고객 주소 (있는 경우)
status: 호출 상태 ("대기중", "배정됨", "완료", "보류")
detectedTimestamp: 호출 감지 시간
assignedDriverId, assignedDriverName: 배정된 대리 기사 정보
trip_summary, departure_set, destination_set, fare_set: 운행 완료 후 기록되는 출발지, 도착지, 요금 등의 운행 정보
designated_drivers 컬렉션: 소속된 대리 기사 목록입니다.
name: 기사 이름
phoneNumber: 전화번호
driverType: 기사 유형 ("대리기사")
status: 현재 상태 ("대기중", "오프라인")
pickup_drivers 컬렉션: 소속된 픽업 기사 목록으로 보입니다.

결론 및 추가 제안
분석 결과, 이 데이터는 지역(Region) -> 사무실(Office) -> [호출(Calls), 대리기사, 픽업기사] 로 이어지는 명확한 계층 구조를 가지고 있습니다. CallDetector라는 이름에서 유추했듯이, 핵심 기능은 calls 컬렉션에 고객의 전화 수신 기록을 저장하고, 이 호출을 기사에게 배정하며 상태를 추적하는 것입니다.

