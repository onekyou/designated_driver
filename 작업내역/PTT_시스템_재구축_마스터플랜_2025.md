# 🎯 **새로운 PTT 시스템 구축 계획서**

**작성일**: 2025-01-29  
**작성자**: System Architect  
**버전**: 1.0

---

## 📌 **프로젝트 개요**

### **목표**
완전히 새로운 아키텍처로 **단순하고 안정적인 PTT 시스템** 구축

### **핵심 요구사항**
1. ✅ Agora 공식 토큰 기반 실시간 음성 통신
2. ✅ 볼륨키를 통한 즉각적인 PTT 제어
3. ✅ 스마트 자동 채널 참여
4. ✅ 비용 최적화 (유휴 시 자동 연결 해제)
5. ✅ 완벽한 백그라운드 작동
6. ✅ Android 15 완벽 호환

---

## 🏗️ **아키텍처 설계**

### **시스템 구조도**
```
┌─────────────────────────────────────────┐
│            UI Layer (Activity)           │
├─────────────────────────────────────────┤
│         PTT Controller (단일 진입점)      │
├─────────────────────────────────────────┤
│   Core Module  │  Support Module         │
│   ┌──────────┐ │  ┌─────────────┐      │
│   │RTC Engine│ │  │Token Manager│      │
│   └──────────┘ │  └─────────────┘      │
│   ┌──────────┐ │  ┌─────────────┐      │
│   │Audio Mgr │ │  │Signal Service│      │
│   └──────────┘ │  └─────────────┘      │
├─────────────────────────────────────────┤
│        Background Service Layer          │
│   ┌──────────────────────────────┐      │
│   │  Foreground Service (상시)    │      │
│   │  + Accessibility Service      │      │
│   └──────────────────────────────┘      │
└─────────────────────────────────────────┘
```

---

## 📅 **단계별 구현 계획**

### **🔵 Phase 1: 기초 구축 (3일)**

#### **Day 1: 클린 스타트**
```kotlin
// 1. 프로젝트 정리
- 기존 PTT 코드 백업 (branch: legacy-ptt)
- 불필요한 의존성 제거
- 새 패키지 구조 생성:
  com.designated.{app}.ptt/
    ├── core/
    ├── service/
    ├── ui/
    └── util/
```

#### **Day 2: 코어 모듈 구현**
```kotlin
// SimplePTTEngine.kt
class SimplePTTEngine {
    private var rtcEngine: RtcEngine? = null
    private var state = PTTState.DISCONNECTED
    
    fun initialize(context: Context): Result<Unit> {
        return try {
            val config = RtcEngineConfig().apply {
                mContext = context.applicationContext
                mAppId = BuildConfig.AGORA_APP_ID
                mEventHandler = eventHandler
                mChannelProfile = CHANNEL_PROFILE_COMMUNICATION
                mAudioScenario = AUDIO_SCENARIO_DEFAULT
            }
            rtcEngine = RtcEngine.create(config)
            configureAudio()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun configureAudio() {
        rtcEngine?.apply {
            setDefaultAudioRoutetoSpeakerphone(true)
            setEnableSpeakerphone(true)
            enableAudio()
            muteLocalAudioStream(true) // 기본 음소거
        }
    }
}
```

#### **Day 3: 토큰 관리**
```kotlin
// TokenManager.kt
class TokenManager(private val functions: FirebaseFunctions) {
    private val cache = mutableMapOf<String, TokenData>()
    
    suspend fun getToken(channelName: String): String {
        // 캐시 확인
        cache[channelName]?.let { 
            if (!it.isExpired()) return it.token 
        }
        
        // 새 토큰 요청
        val result = functions
            .getHttpsCallable("generateAgoraToken")
            .call(mapOf("channelName" to channelName))
            .await()
            
        val token = (result.data as Map<*, *>)["token"] as String
        cache[channelName] = TokenData(token, System.currentTimeMillis())
        return token
    }
}
```

---

### **🔵 Phase 2: PTT 기본 기능 (2일)**

#### **Day 4: PTT 컨트롤러**
```kotlin
// PTTController.kt (싱글톤)
object PTTController {
    private val engine = SimplePTTEngine()
    private val tokenManager = TokenManager()
    private var currentChannel: String? = null
    
    suspend fun startPTT(): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 채널명 생성
                val channel = "${regionId}_${officeId}_ptt"
                
                // 2. 토큰 획득
                val token = tokenManager.getToken(channel)
                
                // 3. 채널 연결 (없으면)
                if (currentChannel != channel) {
                    engine.joinChannel(channel, token)
                    currentChannel = channel
                }
                
                // 4. 마이크 활성화
                engine.startTransmit()
                
                Result.success(Unit)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    fun stopPTT() {
        engine.stopTransmit()
        scheduleDisconnect() // 10초 후 연결 해제
    }
}
```

#### **Day 5: UI 통합**
```kotlin
// PTTButton.kt (Composable)
@Composable
fun PTTButton(modifier: Modifier = Modifier) {
    var isPressing by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()
    
    Box(
        modifier = modifier
            .size(120.dp)
            .pointerInput(Unit) {
                detectTapGestures(
                    onPress = {
                        isPressing = true
                        scope.launch { PTTController.startPTT() }
                        tryAwaitRelease()
                        isPressing = false
                        PTTController.stopPTT()
                    }
                )
            }
    ) {
        // UI 구현
    }
}
```

---

### **🔵 Phase 3: 볼륨키 지원 (2일)**

#### **Day 6: 접근성 서비스**
```kotlin
// PTTAccessibilityService.kt
class PTTAccessibilityService : AccessibilityService() {
    override fun onKeyEvent(event: KeyEvent): Boolean {
        if (!isPTTEnabled()) return super.onKeyEvent(event)
        
        when (event.keyCode) {
            KeyEvent.KEYCODE_VOLUME_UP,
            KeyEvent.KEYCODE_VOLUME_DOWN -> {
                when (event.action) {
                    KeyEvent.ACTION_DOWN -> handlePTTStart()
                    KeyEvent.ACTION_UP -> handlePTTStop()
                }
                return true // 이벤트 소비
            }
        }
        return super.onKeyEvent(event)
    }
}
```

#### **Day 7: 디바운싱 및 안정화**
```kotlin
// PTTDebouncer.kt
class PTTDebouncer {
    private var lastEventTime = 0L
    private val MIN_INTERVAL = 200L
    
    fun shouldProcess(): Boolean {
        val now = System.currentTimeMillis()
        if (now - lastEventTime < MIN_INTERVAL) return false
        lastEventTime = now
        return true
    }
}
```

---

### **🔵 Phase 4: 자동 채널 참여 (3일)**

#### **Day 8: FCM 시그널링**
```kotlin
// PTTSignalingService.kt
class PTTSignalingService : FirebaseMessagingService() {
    override fun onMessageReceived(message: RemoteMessage) {
        when (message.data["type"]) {
            "PTT_START" -> {
                val channel = message.data["channel"] ?: return
                PTTController.autoJoin(channel)
            }
            "PTT_END" -> {
                // 선택적 처리
            }
        }
    }
}
```

#### **Day 9: 자동 참여 로직**
```kotlin
// PTTController에 추가
suspend fun autoJoin(channel: String) {
    if (currentChannel == channel) return // 이미 연결됨
    
    withContext(Dispatchers.IO) {
        val token = tokenManager.getToken(channel)
        engine.joinChannel(channel, token, receiveOnly = true)
        currentChannel = channel
    }
}
```

#### **Day 10: 상태 동기화**
```kotlin
// 송신 시작 시 FCM 전송
private fun notifyPTTStart() {
    FCMHelper.sendToChannel(
        channel = currentChannel,
        data = mapOf(
            "type" to "PTT_START",
            "userId" to getUserId(),
            "timestamp" to System.currentTimeMillis()
        )
    )
}
```

---

### **🔵 Phase 5: 백그라운드 최적화 (2일)**

#### **Day 11: Foreground Service**
```kotlin
// PTTForegroundService.kt
class PTTForegroundService : Service() {
    override fun onCreate() {
        super.onCreate()
        startForeground(NOTIFICATION_ID, createNotification())
        
        // WakeLock 획득 (CPU 유지)
        wakeLock = powerManager.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "PTT:WakeLock"
        )
        wakeLock.acquire(10*60*1000L) // 10분
    }
    
    private fun createNotification(): Notification {
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("PTT 활성화")
            .setContentText("볼륨키로 PTT 사용 가능")
            .setSmallIcon(R.drawable.ic_ptt)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()
    }
}
```

#### **Day 12: Android 15 대응**
```kotlin
// Android15Compat.kt
object Android15Compat {
    fun setupPermissions(activity: Activity) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.VANILLA_ICE_CREAM) {
            // 새로운 권한 모델
            requestExactAlarmPermission(activity)
            requestForegroundServicePermission(activity)
        }
    }
    
    fun maintainAccessibilityService(context: Context) {
        // 주기적 체크 및 재활성화
        WorkManager.getInstance(context)
            .enqueueUniquePeriodicWork(
                "accessibility_check",
                ExistingPeriodicWorkPolicy.KEEP,
                PeriodicWorkRequestBuilder<AccessibilityCheckWorker>(
                    15, TimeUnit.MINUTES
                ).build()
            )
    }
}
```

---

### **🔵 Phase 6: 비용 최적화 (1일)**

#### **Day 13: 스마트 연결 해제**
```kotlin
// ConnectionOptimizer.kt
class ConnectionOptimizer {
    private var disconnectJob: Job? = null
    private val IDLE_TIMEOUT = 10_000L // 10초
    
    fun onActivityDetected() {
        disconnectJob?.cancel()
    }
    
    fun onIdleDetected() {
        disconnectJob = GlobalScope.launch {
            delay(IDLE_TIMEOUT)
            if (PTTController.isIdle()) {
                PTTController.disconnect()
                Log.d("PTT", "Auto disconnected after ${IDLE_TIMEOUT}ms idle")
            }
        }
    }
}
```

---

### **🔵 Phase 7: 테스트 및 안정화 (2일)**

#### **Day 14: 통합 테스트**
```kotlin
// 테스트 시나리오
class PTTIntegrationTest {
    @Test fun test_BasicPTT() { }
    @Test fun test_VolumeKeyPTT() { }
    @Test fun test_AutoJoin() { }
    @Test fun test_BackgroundOperation() { }
    @Test fun test_AutoDisconnect() { }
    @Test fun test_Android15Compatibility() { }
}
```

#### **Day 15: 최종 최적화**
- 메모리 누수 체크
- 배터리 사용량 최적화
- 로그 레벨 조정
- 에러 처리 강화

---

## 📊 **성공 지표**

### **기능적 지표**
- ✅ PTT 연결 시간 < 1초
- ✅ 음성 지연 < 200ms
- ✅ 자동 참여 성공률 > 95%
- ✅ 백그라운드 생존율 > 99%

### **비기능적 지표**
- ✅ 배터리 사용량 < 5%/시간
- ✅ 메모리 사용량 < 50MB
- ✅ 코드 복잡도 50% 감소
- ✅ 유지보수 시간 70% 감소

---

## ⚡ **Quick Start Guide**

### **1주차: 핵심 구현**
- Phase 1-3 완료
- 기본 PTT + 볼륨키 작동

### **2주차: 고급 기능**
- Phase 4-6 완료
- 자동 참여 + 백그라운드

### **3주차: 완성**
- Phase 7 + 배포 준비
- 문서화 및 교육

---

## 💡 **핵심 차별점**

### **이전 시스템 대비**
| 항목 | 기존 | 신규 | 개선율 |
|------|------|------|--------|
| 코드 라인 | 5000+ | 1500 | -70% |
| 클래스 수 | 15+ | 6 | -60% |
| 복잡도 | 매우 높음 | 낮음 | -80% |
| 디버깅 시간 | 2-3시간 | 10분 | -90% |

### **기술적 개선**
1. **단일 책임 원칙**: 각 클래스가 하나의 역할만
2. **의존성 최소화**: 3단계 이하 계층
3. **명확한 상태 관리**: State Pattern 적용
4. **에러 복구**: Fail-safe 설계

---

## 📋 **구현 체크리스트**

### **개발 전 준비**
- [ ] 기존 코드 백업 (git branch)
- [ ] 테스트 디바이스 준비 (Android 15 포함)
- [ ] Agora Console 설정 확인
- [ ] Firebase Functions 설정
- [ ] 개발 환경 구성

### **Phase별 완료 기준**
- [ ] Phase 1: 코어 엔진 초기화 성공
- [ ] Phase 2: 기본 PTT 송수신 가능
- [ ] Phase 3: 볼륨키 PTT 작동
- [ ] Phase 4: 자동 채널 참여 확인
- [ ] Phase 5: 백그라운드 안정성 확보
- [ ] Phase 6: 10초 자동 해제 작동
- [ ] Phase 7: 전체 시나리오 테스트 통과

### **품질 체크**
- [ ] 메모리 누수 없음
- [ ] 배터리 사용량 기준 충족
- [ ] 응답 시간 1초 이내
- [ ] 에러 핸들링 완료
- [ ] 로그 레벨 production 설정

---

## 🚀 **마이그레이션 전략**

### **단계적 전환**
1. **Week 1**: 신규 시스템 개발 (기존 유지)
2. **Week 2**: 알파 테스트 (선택된 사용자)
3. **Week 3**: 베타 테스트 (50% 사용자)
4. **Week 4**: 전체 배포

### **롤백 계획**
- 기존 코드 branch 유지
- Feature Flag로 즉시 전환 가능
- 사용자별 선택적 활성화

---

## 📝 **참고 문서**

### **기술 문서**
- [Agora RTC SDK Documentation](https://docs.agora.io/en/voice-calling/get-started/get-started-sdk)
- [Android 15 Compatibility Guide](https://developer.android.com/about/versions/15)
- [Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging)

### **내부 문서**
- 기존 PTT 시스템 분석 보고서
- 사용자 피드백 정리
- 성능 벤치마크 결과

---

## 🎯 **최종 목표**

이 계획을 통해 **15일 내에**:
- ✅ 70% 단순화된 코드베이스
- ✅ 90% 향상된 유지보수성
- ✅ 99.9% 안정성
- ✅ 완벽한 Android 15 호환성

을 달성하여 **"단순하지만 강력한"** PTT 시스템을 구축합니다.

---

**문서 끝**

*최종 수정: 2025-01-29*  
*다음 검토: 구현 시작 시점*